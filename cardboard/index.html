<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="description" content="参考：初めてのThree.js 第2版 サンプル https://oreilly-japan.github.io/learning-three-js-2e-ja-support/">
  <title>Three.js sample</title>
  <script src="three.min.js"></script>

  <script src="stats.js"></script>
  <script src="dat.gui.js"></script>

  <!-- vr -->
  <script src="CardboardEffect.js"></script>
  <script src="DeviceOrientationControls.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div id="Stats-output">
  </div>

  <div id="WebGL-output">
  </div>

  <!-- JavaScript -->
  <script>

    function init() {
      var scene = new THREE.Scene();

      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.x = 8;
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      var webGLRenderer = new THREE.WebGLRenderer();
      webGLRenderer.setClearColor(new THREE.Color(0x000));
      webGLRenderer.setSize(window.innerWidth, window.innerHeight);
      webGLRenderer.shadowMap.enabled = true;

      document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);
      webGLRenderer.domElement.addEventListener('touchstart', function() {
        if (!document.mozFullScreen && !document.webkitIsFullScreen) {
          var canvas = webGLRenderer.domElement;
          var requestFullScreen = canvas.mozRequestFullScreen || canvas.webkitRequestFullScreen;
          requestFullScreen.bind(canvas)();
        }
        else {
          removeSelectedDebri(10.2, earth.position);
        }
      }.bind(this));
      window.addEventListener('resize', onWindowResize, false);
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        effect.setSize(window.innerWidth, window.innerHeight);
      }

      var raycaster = new THREE.Raycaster();

      var earth = createEarthMesh(new THREE.SphereGeometry(10, 80, 80));
      earth.position.y = -10;
      scene.add(earth);

      var air = createAirMesh(new THREE.SphereGeometry(10.1, 80, 80));
      air.position.copy(earth.position);
      scene.add(air);

      var moon = createMoonMesh(new THREE.SphereGeometry(5, 20, 20));
      moon.position.x = -50;
      earth.add(moon);

      // start
      var pos = earth.position;
      var rad = Math.abs(moon.position.x);
      earth.add(createStarPoints(100, 5, pos, rad, true));
      earth.add(createStarPoints(500, 3, pos, rad));
      earth.add(createStarPoints(2000, 2, pos, rad));

      // debris
      var earthAndDebris = [earth];
      var debris = [];
      for (var i = 0; i < 30; i++) {
        var debri = createDebri(10.2, earth.position);
        earth.add(debri);
        debris.push(debri);
        earthAndDebris.push(debri);
      }

      var selectedDebri;

      var controls = new THREE.DeviceOrientationControls(camera);
      var effect = new THREE.CardboardEffect(webGLRenderer);

      var ambi = new THREE.AmbientLight(0x181818);
      scene.add(ambi);

      var directionalLight = new THREE.DirectionalLight(0xffffff);
      directionalLight.position.set(100, 0, 150);
      earth.add(directionalLight);

      var directionalBackLight = new THREE.DirectionalLight(0xffffff);
      directionalBackLight.position.copy(directionalLight.position.clone().negate());
      directionalBackLight.intensity = 0.7;
      earth.add(directionalBackLight);

      // call the render function
      var step = 0;

      render();

      function createEarthMesh(geom) {
        var textureLoader = new THREE.TextureLoader();
        var planetTexture = textureLoader.load("./textures/planets/Earth.png");
        var specularTexture = textureLoader.load("./textures/planets/EarthSpec.png");
        var normalTexture = textureLoader.load("./textures/planets/EarthNormal.png");

        var planetMaterial = new THREE.MeshPhongMaterial();
        planetMaterial.specularMap = specularTexture;
        planetMaterial.specular = new THREE.Color(0x4444aa);
        planetMaterial.shininess = 5;
        planetMaterial.normalMap = normalTexture;
        planetMaterial.normalScale = new THREE.Vector2(5, 5);
        planetMaterial.map = planetTexture;

        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]);

        return mesh;
      }

      function createAirMesh(geom) {
        var planetMaterial = new THREE.MeshPhongMaterial();
        planetMaterial.side = THREE.BackSide;
        planetMaterial.transparent = true;
        planetMaterial.opacity = 0.2;
        planetMaterial.color = new THREE.Color(0xffffff);

        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]);

        return mesh;
      }

      function createMoonMesh(geom) {
        var textureLoader = new THREE.TextureLoader();
        var planetTexture = textureLoader.load("./textures/planets/Moon.png");
        var normalTexture = textureLoader.load("./textures/planets/Mars-normalmap_2k.png");

        var planetMaterial = new THREE.MeshPhongMaterial();
        planetMaterial.normalMap = normalTexture;
        planetMaterial.normalScale = new THREE.Vector2(5, 5);
        planetMaterial.map = planetTexture;
        planetMaterial.specularMap = planetTexture;
        planetMaterial.specular = new THREE.Color(0x444400);
        planetMaterial.shininess = 0;

        var mesh = new THREE.Mesh(geom, planetMaterial);

        return mesh;
      }

      function createStarPoints(num, size, center, radius, red) {
        var geom = new THREE.Geometry();

        var textureLoader = new THREE.TextureLoader();
        var texture = textureLoader.load(red ?
          "./textures/lensflare/lensflare0.png" :
          "./textures/lensflare/lensflare0_white.png"
        );
        var material = new THREE.PointsMaterial({size: size, map: texture});

        for (var i = 0; i < num; i++) {
          var theta = Math.random() * 2 * Math.PI;
          var phi = Math.random() * 2 * Math.PI;
          var r = radius * (1.5 + Math.random() / 10);
          var particle = new THREE.Vector3(
            r * Math.sin(theta) * Math.cos(phi),
            r * Math.sin(theta) * Math.sin(phi),
            r * Math.cos(theta)
          );
          geom.vertices.push(particle);
        }
        cloud = new THREE.Points(geom, material);
        cloud.sortParticles = true;
        return cloud;
      }

      function putDebriRandom(mesh, limitRadius, center) {
        var theta = Math.random() * 2 * Math.PI;
        var phi = Math.random() * 2 * Math.PI;
        var r = limitRadius * 2 + Math.random() / 100;
        mesh.position.set(
          center.x + r * Math.sin(theta) * Math.cos(phi),
          center.y + r * Math.sin(theta) * Math.sin(phi),
          center.z + r * Math.cos(theta)
        );
      }


      function createDebri(limitRadius, center) {
        var textureLoader = new THREE.TextureLoader();
        var spriteMaterial = new THREE.SpriteMaterial({
          opacity: 0.6,
          color: 0xffffff,
          transparent: true,
          map: textureLoader.load("./textures/particles/sprite-sheet.png")
        });
        // material.emissive = new THREE.Color(0x333333);
        // material.specular = new THREE.Color(0x4444aa);
        // material.shininess = 100;
        // var mesh = new THREE.Mesh(geom, material);
        spriteMaterial.map.offset = new THREE.Vector2(0.2 * Math.floor(Math.random * 5), 0);
        spriteMaterial.map.repeat = new THREE.Vector2(1 / 5, 1);
        spriteMaterial.depthTest = false;

        spriteMaterial.blending = THREE.AdditiveBlending;

        var mesh = new THREE.Sprite(spriteMaterial);

        putDebriRandom(mesh, limitRadius, center);
        mesh.rotation.x = Math.random() * 2 * Math.PI;
        mesh.rotation.y = Math.random() * 2 * Math.PI;
        mesh.rotation.z = Math.random() * 2 * Math.PI;
        mesh.drotx = (Math.random() - 0.5) / 10;
        mesh.droty = (Math.random() - 0.5) / 10;
        mesh.drotz = (Math.random() - 0.5) / 10;
        return mesh;
      }

      function removeSelectedDebri(limitRadius, center) {
        if (selectedDebri) {
          putDebriRandom(selectedDebri, limitRadius, center);
          deselectDebri();
        }
      }

      function selectDebri() {
        raycaster.setFromCamera({x: 0, y: 0}, camera);
        var intersects = raycaster.intersectObjects(earthAndDebris);
        if (intersects.length === 0) {
          deselectDebri();
        }
        else {
          for (var i = 0; i < intersects.length; i++) {
            var debri = intersects[i].object;
            if (debri === earth) {
              console.log(debri === earth);
              break;
            }
            if (selectedDebri !== debri) {
              deselectDebri();
              selectedDebri = debri;
              debri.scale.set(2, 2, 2);
              break;
            }
          }
        }
      }

      function deselectDebri() {
        if (selectedDebri) {
          selectedDebri.scale.set(1, 1, 1);
        }
        selectedDebri = null;
      }

      function render() {
        debris.forEach(function(debri) {
          debri.rotation.x += debri.drotx;
          debri.rotation.y += debri.droty;
          debri.rotation.z += debri.drotz;
        });

        selectDebri();

        controls.update();

        earth.rotation.z -= 0.001;

        requestAnimationFrame(render);
        effect.render(scene, camera);
      }
    }
    window.onload = init;

  </script>
</body>
</html>
